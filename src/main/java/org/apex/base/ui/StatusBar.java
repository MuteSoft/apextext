/*
 * StatusBar.java
 * Created on 29 May, 2008, 10:57 PM 
 *
 * Copyright (C) 2008 Mrityunjoy Saha
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.apex.base.ui;

import javax.swing.JProgressBar;
import org.apex.base.constant.MenuConstants;
import org.apex.base.core.ActionManager;
import org.apex.base.core.EditorBase;
import org.apex.base.core.MenuManager;
import org.apex.base.data.InputParams;
import org.apex.base.data.OutputParams;
import org.apex.base.data.TypingMode;
import org.apex.base.logging.Logger;
import org.apex.base.util.StringUtil;

/**
 * The editor status bar. It shows file's read only status, insertion mode,
 * line number and column number.
 * @author Mrityunjoy Saha
 * @version 1.0
 * @since Apex 1.0
 */
public class StatusBar extends javax.swing.JPanel {

    /**
     * Display text for non-editable state of a document.
     */
    public static final String READ_ONLY_STATUS = "Read Only";
    /**
     *  Display text for editable state of a document.
     */
    public static final String WRITEABLE_STATUS = "Writable";

    /** 
     * Creates new form {@code StatusBar}.
     */
    public StatusBar() {
        initComponents();
    }

    /**
     * Sets edit status.
     * @param canWrite A boolean that indicates whether or not a document is ediatble.
     */
    public void setWritableStatus(boolean canWrite) {
        if (canWrite) {
            if (StringUtil.isNullOrEmpty(writable.getText()) || !writable.
                    getText().trim().equals(
                    WRITEABLE_STATUS)) {
                this.writable.setText(WRITEABLE_STATUS);
            }
        } else {
            if (StringUtil.isNullOrEmpty(writable.getText()) || !writable.
                    getText().trim().equals(
                    READ_ONLY_STATUS)) {
                this.writable.setText(READ_ONLY_STATUS);
            }
        }
    }

    /**
     * Sets the enable status of writable file.
     * @param enabled A boolean that indicates whether or not writable status display to be enabled.
     */
    public void setWritableStatusEnabled(boolean enabled) {
        if (!StringUtil.isNullOrEmpty(writable.getText())) {
            writable.setEnabled(enabled);
        }
    }

    /**
     * Sets the enable status of typing mode display.
     * @param enabled A boolean that indicates whether or not typing mode display to be enabled.
     */
    public void setTypingModeEnabled(boolean enabled) {
        if (!StringUtil.isNullOrEmpty(typingModeLabel.getText())) {
            typingModeLabel.setEnabled(enabled);
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        caretPositionInfoLabel = new javax.swing.JLabel();
        generalInfoLabel = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        typingModeLabel = new javax.swing.JLabel();
        jSeparator3 = new javax.swing.JSeparator();
        writable = new javax.swing.JLabel();
        jSeparator4 = new javax.swing.JSeparator();
        jSeparator5 = new javax.swing.JSeparator();
        progressBar = new javax.swing.JProgressBar();

        setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, java.awt.Color.gray));
        setPreferredSize(new java.awt.Dimension(473, 20));

        caretPositionInfoLabel.setText("1 : 1");

        generalInfoLabel.setText(EditorBase.getContext().getEditorProperties().getEditorTitle()+" started...");

        jSeparator2.setOrientation(javax.swing.SwingConstants.VERTICAL);

        typingModeLabel.setText("INS");

        jSeparator3.setOrientation(javax.swing.SwingConstants.VERTICAL);

        writable.setText(WRITEABLE_STATUS);
        writable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                writableMouseClicked(evt);
            }
        });

        jSeparator4.setOrientation(javax.swing.SwingConstants.VERTICAL);

        jSeparator5.setOrientation(javax.swing.SwingConstants.VERTICAL);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(generalInfoLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, 145, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(writable, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(typingModeLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(caretPositionInfoLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(16, 16, 16))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(generalInfoLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 17, Short.MAX_VALUE)
                .addComponent(writable, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(typingModeLabel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 18, Short.MAX_VALUE))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addComponent(caretPositionInfoLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 18, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addComponent(jSeparator5, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

private void writableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_writableMouseClicked
    if (evt.getClickCount() == 2) {
        ActionManager.setActionSelected(MenuConstants.READ_ONLY,
                !ActionManager.isActionSelected(MenuConstants.READ_ONLY));
        MenuManager.getMenuById(MenuConstants.READ_ONLY).
                processMenu(
                new InputParams(),
                new OutputParams());
    }
}//GEN-LAST:event_writableMouseClicked
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel caretPositionInfoLabel;
    private javax.swing.JLabel generalInfoLabel;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JSeparator jSeparator5;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JLabel typingModeLabel;
    private javax.swing.JLabel writable;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns the general message.
     * @return The general message.
     * @see #setGeneralInfo(java.lang.String)
     */
    public String getGeneralInfo() {
        return this.generalInfoLabel.getText();
    }

    /**
     * Sets the general message.
     * @param generalInfo A message.
     * @see #getGeneralInfo()
     */
    public void setGeneralInfo(String generalInfo) {
        generalInfoLabel.setText(generalInfo);
    }

    /**
     * Returns the caret position information. At any given time caret position info contains
     * current line number and column number based on current caret position.
     * @return The caret position information.
     * @see #setCaretPositionInfo(java.lang.String)
     */
    public String getCaretPositionInfo() {
        return this.caretPositionInfoLabel.getText();
    }

    /**
     * Sets the display text about caret position. At any given time it displays
     * current line number and column number based on current caret position.
     * @param caretPositionInfo  Caret position information.
     * @see #getCaretPositionInfo()
     */
    public void setCaretPositionInfo(String caretPositionInfo) {
        caretPositionInfoLabel.setText(caretPositionInfo);
    }

    /**
     * Sets a typing mode. It can be either {@code TypingMode.INSERT}
     * or {@code TypingMode.OVERWRITE}.
     * @param mode A typing mode.
     * @see TypingMode#INSERT
     * @see TypingMode#OVERWRITE
     * @see #getTypingMode()
     */
    public void setTypingMode(TypingMode mode) {
        if (mode == null) {
            this.typingModeLabel.setText(TypingMode.INSERT.getDisplayText());
        } else {
            this.typingModeLabel.setText(mode.getDisplayText());
        }
    }

    /**
     * Returns the current typing mode.
     * @return The typing mode.
     * @see #setTypingMode(org.apex.base.data.TypingMode)
     */
    public String getTypingMode() {
        return this.typingModeLabel.getText();
    }

    /**
     * Determines the line number based on current caret position.
     * @return The current line number.
     */
    public int getLineNumber() {
        int lineNumber = 1;
        String caretPositionInfo = this.caretPositionInfoLabel.getText();
        try {
            if (!StringUtil.isNullOrEmpty(caretPositionInfo)) {
                int startIndex = 0;
                int endIndex = caretPositionInfo.indexOf(":");
                lineNumber = Integer.parseInt(caretPositionInfo.substring(
                        startIndex,
                        endIndex).trim());
            }
        } catch (NumberFormatException nfe) {
            Logger.logWarning(
                    "Could not determine line number from caret position info.",
                    nfe);
        } catch (ArrayIndexOutOfBoundsException ae) {
            Logger.logWarning(
                    "Could not determine line number from caret position info.",
                    ae);
        } catch (NullPointerException npe) {
            Logger.logWarning(
                    "Could not determine line number from caret position info.",
                    npe);
        } catch (Exception ex) {
            Logger.logWarning(
                    "Could not determine line number from caret position info.",
                    ex);
        }
        return lineNumber;
    }

    /**
     * Determines the column number based on current caret position.
     * @return The current column number.
     */
    public int getColumn() {
        int column = 1;
        String caretPositionInfo = this.caretPositionInfoLabel.getText();
        try {
            if (!StringUtil.isNullOrEmpty(caretPositionInfo)) {
                int startIndex = caretPositionInfo.indexOf(":") + 1;
                column = Integer.parseInt(caretPositionInfo.substring(startIndex).
                        trim());
            }
        } catch (NumberFormatException nfe) {
            Logger.logWarning(
                    "Could not determine column number from caret position info.",
                    nfe);
        } catch (ArrayIndexOutOfBoundsException ae) {
            Logger.logWarning(
                    "Could not determine column number from caret position info.",
                    ae);
        } catch (NullPointerException npe) {
            Logger.logWarning(
                    "Could not determine column number from caret position info.",
                    npe);
        } catch (Exception ex) {
            Logger.logWarning(
                    "Could not determine column number from caret position info.",
                    ex);
        }
        return column;
    }

    public JProgressBar getProgressBar() {
        return progressBar;
    }    
}
